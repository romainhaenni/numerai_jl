        - using Pkg
        - Pkg.activate(joinpath(@__DIR__, ".."))
        - 
        - push!(LOAD_PATH, joinpath(@__DIR__, "..", "src"))
        - 
        - using Test
        - using NumeraiTournament
        - using HTTP
        - using Dates
        - using Logging
        - using LoggingExtras
        - using Downloads
        - using Random
        - 
        - # Import the Retry module directly
        - include(joinpath(@__DIR__, "..", "src", "api", "retry.jl"))
        - using .Retry: RetryConfig, exponential_backoff, should_retry, with_retry, with_graphql_retry, with_download_retry, CircuitBreaker, with_circuit_breaker, record_failure, record_success, is_open
        - 
        - # Set up basic logging for testing
        - logger = ConsoleLogger(stdout, Logging.Debug)
        - 
        1 @testset "Retry Logic Tests" begin
        -     
        1     @testset "RetryConfig Creation and Validation" begin
        2         @testset "Default RetryConfig" begin
        3             config = RetryConfig()
        2             @test config.max_attempts == 3
        2             @test config.initial_delay == 1.0
        2             @test config.max_delay == 60.0
        2             @test config.exponential_base == 2.0
        2             @test config.jitter == true
        2             @test HTTP.ExceptionRequest.StatusError in config.retry_on
        2             @test HTTP.TimeoutError in config.retry_on
        2             @test HTTP.ConnectionPool.ConnectError in config.retry_on
        -         end
        -         
        0         @testset "Custom RetryConfig" begin
        3             config = RetryConfig(
        -                 max_attempts = 5,
        -                 initial_delay = 2.5,
        -                 max_delay = 120.0,
        -                 exponential_base = 1.5,
        -                 jitter = false,
        -                 retry_on = Type[HTTP.TimeoutError]
        -             )
        2             @test config.max_attempts == 5
        2             @test config.initial_delay == 2.5
        2             @test config.max_delay == 120.0
        2             @test config.exponential_base == 1.5
        2             @test config.jitter == false
        2             @test config.retry_on == Type[HTTP.TimeoutError]
        -         end
        -         
        0         @testset "Validation edge cases" begin
        -             # Test with zero attempts
        3             config_zero = RetryConfig(max_attempts = 0)
        2             @test config_zero.max_attempts == 0
        -             
        -             # Test with very high delays
        1             config_high = RetryConfig(initial_delay = 1000.0, max_delay = 2000.0)
        2             @test config_high.initial_delay == 1000.0
        2             @test config_high.max_delay == 2000.0
        -         end
        -     end
        -     
        0     @testset "Exponential Backoff Calculation" begin
        2         @testset "Basic exponential backoff without jitter" begin
        3             config = RetryConfig(
        -                 initial_delay = 1.0,
        -                 max_delay = 60.0,
        -                 exponential_base = 2.0,
        -                 jitter = false
        -             )
        -             
        2             @test exponential_backoff(1, config) == 1.0
        2             @test exponential_backoff(2, config) == 2.0
        2             @test exponential_backoff(3, config) == 4.0
        2             @test exponential_backoff(4, config) == 8.0
        2             @test exponential_backoff(5, config) == 16.0
        2             @test exponential_backoff(6, config) == 32.0
        2             @test exponential_backoff(7, config) == 60.0  # Capped at max_delay
        2             @test exponential_backoff(10, config) == 60.0  # Still capped
        -         end
        -         
        0         @testset "Exponential backoff with different base" begin
        3             config = RetryConfig(
        -                 initial_delay = 2.0,
        -                 max_delay = 100.0,
        -                 exponential_base = 1.5,
        -                 jitter = false
        -             )
        -             
        2             @test exponential_backoff(1, config) == 2.0
        2             @test exponential_backoff(2, config) == 3.0
        2             @test exponential_backoff(3, config) == 4.5
        2             @test exponential_backoff(4, config) == 6.75
        -         end
        -         
        0         @testset "Exponential backoff with jitter" begin
        3             Random.seed!(42)  # For reproducible tests
        1             config = RetryConfig(
        -                 initial_delay = 1.0,
        -                 max_delay = 60.0,
        -                 exponential_base = 2.0,
        -                 jitter = true
        -             )
        -             
        -             # With jitter, delays should be between 100% and 125% of base delay
        1             delay1 = exponential_backoff(1, config)
        2             @test 1.0 <= delay1 <= 1.25
        -             
        1             delay2 = exponential_backoff(2, config)
        2             @test 2.0 <= delay2 <= 2.5
        -             
        -             # Test multiple calls to ensure jitter varies
        1             delays = [exponential_backoff(2, config) for _ in 1:100]
        2             @test length(unique(delays)) > 1  # Should have variation due to jitter
      103             @test all(d -> 2.0 <= d <= 2.5, delays)
        -         end
        -         
        0         @testset "Max delay capping with jitter" begin
        3             config = RetryConfig(
        -                 initial_delay = 50.0,
        -                 max_delay = 60.0,
        -                 exponential_base = 2.0,
        -                 jitter = true
        -             )
        -             
        -             # Even with jitter, should not exceed max_delay significantly
        1             delay = exponential_backoff(2, config)
        2             @test delay <= 75.0  # 60 * 1.25 = 75.0 (max with 25% jitter)
        -         end
        -     end
        -     
        0     @testset "should_retry Logic" begin
        3         config = RetryConfig()
        -         
        0         @testset "HTTP Status Code Logic" begin
        -             # Create mock HTTP responses for different status codes
        -             
        -             # 5xx errors should retry
        3             response_500 = HTTP.Response(500, "Internal Server Error")
        1             error_500 = HTTP.ExceptionRequest.StatusError(500, "GET", "http://example.com", response_500)
        2             @test should_retry(error_500, config) == true
        -             
        1             response_502 = HTTP.Response(502, "Bad Gateway")
        1             error_502 = HTTP.ExceptionRequest.StatusError(502, "GET", "http://example.com", response_502)
        2             @test should_retry(error_502, config) == true
        -             
        1             response_503 = HTTP.Response(503, "Service Unavailable")
        1             error_503 = HTTP.ExceptionRequest.StatusError(503, "GET", "http://example.com", response_503)
        2             @test should_retry(error_503, config) == true
        -             
        -             # 429 rate limiting should retry
        1             response_429 = HTTP.Response(429, "Too Many Requests")
        1             error_429 = HTTP.ExceptionRequest.StatusError(429, "GET", "http://example.com", response_429)
        2             @test should_retry(error_429, config) == true
        -             
        -             # 4xx client errors should not retry (except 429)
        1             response_400 = HTTP.Response(400, "Bad Request")
        1             error_400 = HTTP.ExceptionRequest.StatusError(400, "GET", "http://example.com", response_400)
        2             @test should_retry(error_400, config) == false
        -             
        1             response_401 = HTTP.Response(401, "Unauthorized")
        1             error_401 = HTTP.ExceptionRequest.StatusError(401, "GET", "http://example.com", response_401)
        2             @test should_retry(error_401, config) == false
        -             
        1             response_404 = HTTP.Response(404, "Not Found")
        1             error_404 = HTTP.ExceptionRequest.StatusError(404, "GET", "http://example.com", response_404)
        2             @test should_retry(error_404, config) == false
        -             
        -             # 2xx and 3xx success codes shouldn't trigger retry logic
        1             response_200 = HTTP.Response(200, "OK")
        1             error_200 = HTTP.ExceptionRequest.StatusError(200, "GET", "http://example.com", response_200)
        2             @test should_retry(error_200, config) == true  # Would retry if it's in retry_on list
        -         end
        -         
        0         @testset "Network Error Types" begin
        -             # TimeoutError should retry
        3             timeout_error = HTTP.TimeoutError(30)  # 30 second timeout
        2             @test should_retry(timeout_error, config) == true
        -             
        -             # ConnectionError should retry  
        1             conn_error = HTTP.ConnectionPool.ConnectError("http://localhost:8080", "Connection refused")
        2             @test should_retry(conn_error, config) == true
        -         end
        -         
        0         @testset "Non-retryable Errors" begin
        -             # ArgumentError should not retry
        3             arg_error = ArgumentError("Invalid argument")
        2             @test should_retry(arg_error, config) == false
        -             
        -             # BoundsError should not retry
        1             bounds_error = BoundsError([1, 2, 3], 5)
        2             @test should_retry(bounds_error, config) == false
        -         end
        -         
        0         @testset "Custom retry_on Configuration" begin
        3             custom_config = RetryConfig(retry_on = Type[ArgumentError, BoundsError])
        -             
        -             # Now ArgumentError should retry
        1             arg_error = ArgumentError("Invalid argument")
        2             @test should_retry(arg_error, custom_config) == true
        -             
        -             # But HTTP errors should not
        1             response_500 = HTTP.Response(500, "Internal Server Error")
        1             error_500 = HTTP.ExceptionRequest.StatusError(500, "GET", "http://example.com", response_500)
        2             @test should_retry(error_500, custom_config) == false
        -         end
        -     end
        -     
        0     @testset "Circuit Breaker State Transitions" begin
        2         @testset "Circuit Breaker Creation" begin
        3             cb = CircuitBreaker()
        2             @test cb.failure_threshold == 5
        2             @test cb.recovery_timeout == 60.0
        2             @test cb.failure_count == 0
        2             @test cb.last_failure_time == 0.0
        2             @test cb.state == :closed
        -         end
        -         
        0         @testset "Custom Circuit Breaker" begin
        3             cb = CircuitBreaker(failure_threshold = 3, recovery_timeout = 30.0)
        2             @test cb.failure_threshold == 3
        2             @test cb.recovery_timeout == 30.0
        2             @test cb.state == :closed
        -         end
        -         
        0         @testset "State Transitions - Closed to Open" begin
        3             cb = CircuitBreaker(failure_threshold = 3)
        -             
        -             # Initially closed
        2             @test cb.state == :closed
        3             @test !is_open(cb)
        -             
        -             # Record failures
        1             record_failure(cb)
        2             @test cb.failure_count == 1
        2             @test cb.state == :closed
        -             
        1             record_failure(cb)
        2             @test cb.failure_count == 2
        2             @test cb.state == :closed
        -             
        1             record_failure(cb)
        2             @test cb.failure_count == 3
        2             @test cb.state == :open
        3             @test is_open(cb)
        -         end
        -         
        0         @testset "State Transitions - Open to Half-Open" begin
        3             cb = CircuitBreaker(failure_threshold = 2, recovery_timeout = 0.1)
        -             
        -             # Force circuit breaker to open state
        1             record_failure(cb)
        1             record_failure(cb)
        2             @test cb.state == :open
        3             @test is_open(cb)
        -             
        -             # Wait for recovery timeout
        1             sleep(0.15)
        -             
        -             # Check should transition to half-open
        3             @test !is_open(cb)
        2             @test cb.state == :half_open
        -         end
        -         
        0         @testset "State Transitions - Half-Open to Closed" begin
        3             cb = CircuitBreaker(failure_threshold = 2)
        1             cb.state = :half_open
        -             
        -             # Record success should close the circuit
        1             record_success(cb)
        2             @test cb.state == :closed
        2             @test cb.failure_count == 0
        -         end
        -         
        0         @testset "State Transitions - Half-Open back to Open" begin
        3             cb = CircuitBreaker(failure_threshold = 2)
        1             cb.state = :half_open
        1             cb.failure_count = 1
        -             
        -             # Another failure should open the circuit again
        1             record_failure(cb)
        2             @test cb.state == :open
        2             @test cb.failure_count == 2
        -         end
        -     end
        -     
        0     @testset "with_retry Success Scenarios" begin
        2         @testset "Function succeeds on first try" begin
        3             call_count = 0
        1             result = with_retry(RetryConfig(max_attempts = 3)) do
        1                 call_count += 1
        1                 return "success"
        -             end
        -             
        2             @test result == "success"
        2             @test call_count == 1
        -         end
        -         
        0         @testset "Function succeeds after retries" begin
        3             call_count = 0
        1             config = RetryConfig(max_attempts = 3, initial_delay = 0.01, jitter = false)
        -             
        1             result = with_retry(config) do
        3                 call_count += 1
        3                 if call_count < 3
        2                     throw(HTTP.TimeoutError(30))
        -                 end
        1                 return "success_after_retry"
        -             end
        -             
        2             @test result == "success_after_retry"
        2             @test call_count == 3
        -         end
        -         
        0         @testset "Return different types" begin
        -             # Test returning various types
        3             int_result = with_retry(RetryConfig()) do
        1                 return 42
        -             end
        2             @test int_result == 42
        -             
        1             dict_result = with_retry(RetryConfig()) do
        2                 return Dict("key" => "value")
        -             end
        2             @test dict_result["key"] == "value"
        -             
        1             nothing_result = with_retry(RetryConfig()) do
        1                 return nothing
        -             end
        2             @test nothing_result === nothing
        -         end
        -     end
        -     
        0     @testset "with_retry Failure Scenarios" begin
        2         @testset "Max retries exceeded with retryable error" begin
        3             call_count = 0
        1             config = RetryConfig(max_attempts = 3, initial_delay = 0.01, jitter = false)
        -             
        2             @test_throws HTTP.TimeoutError begin
        1                 with_retry(config) do
        3                     call_count += 1
        3                     throw(HTTP.TimeoutError(30))
        -                 end
        -             end
        -             
        2             @test call_count == 3  # Should have tried max_attempts times
        -         end
        -         
        0         @testset "Non-retryable error fails immediately" begin
        3             call_count = 0
        1             config = RetryConfig(max_attempts = 3, initial_delay = 0.01)
        -             
        2             @test_throws ArgumentError begin
        1                 with_retry(config) do
        1                     call_count += 1
        1                     throw(ArgumentError("Invalid argument"))
        -                 end
        -             end
        -             
        2             @test call_count == 1  # Should not retry
        -         end
        -         
        0         @testset "HTTP 4xx errors fail immediately" begin
        3             call_count = 0
        1             config = RetryConfig(max_attempts = 3, initial_delay = 0.01)
        -             
        2             @test_throws HTTP.ExceptionRequest.StatusError begin
        1                 with_retry(config) do
        1                     call_count += 1
        1                     response = HTTP.Response(404, "Not Found")
        1                     throw(HTTP.ExceptionRequest.StatusError(404, "GET", "http://example.com", response))
        -                 end
        -             end
        -             
        2             @test call_count == 1  # Should not retry 404
        -         end
        -         
        0         @testset "Mixed error types during retries" begin
        3             call_count = 0
        1             config = RetryConfig(max_attempts = 4, initial_delay = 0.01, jitter = false)
        -             
        2             @test_throws ArgumentError begin
        1                 with_retry(config) do
        3                     call_count += 1
        3                     if call_count <= 2
        2                         throw(HTTP.TimeoutError(30))
        -                     else
        1                         throw(ArgumentError("Non-retryable"))
        -                     end
        -                 end
        -             end
        -             
        2             @test call_count == 3  # Two timeouts, then non-retryable error
        -         end
        -     end
        -     
        0     @testset "with_circuit_breaker Integration" begin
        2         @testset "Circuit breaker allows successful operations" begin
        3             cb = CircuitBreaker(failure_threshold = 2)
        1             call_count = 0
        -             
        1             result = with_circuit_breaker(cb) do
        1                 call_count += 1
        1                 return "success"
        -             end
        -             
        2             @test result == "success"
        2             @test call_count == 1
        2             @test cb.state == :closed
        -         end
        -         
        0         @testset "Circuit breaker opens after failures" begin
        3             cb = CircuitBreaker(failure_threshold = 2)
        1             call_count = 0
        -             
        -             # First failure
        2             @test_throws ErrorException begin
        1                 with_circuit_breaker(cb) do
        1                     call_count += 1
        1                     throw(ErrorException("First failure"))
        -                 end
        -             end
        2             @test cb.state == :closed
        2             @test cb.failure_count == 1
        -             
        -             # Second failure - should open circuit
        2             @test_throws ErrorException begin
        1                 with_circuit_breaker(cb) do
        1                     call_count += 1
        1                     throw(ErrorException("Second failure"))
        -                 end
        -             end
        2             @test cb.state == :open
        2             @test cb.failure_count == 2
        -             
        -             # Third call should fail due to open circuit
        2             @test_throws ErrorException begin
        1                 with_circuit_breaker(cb) do
        0                     call_count += 1
        0                     return "should not reach"
        -                 end
        -             end
        2             @test call_count == 2  # Third call not executed
        -         end
        -         
        0         @testset "Circuit breaker recovery" begin
        3             cb = CircuitBreaker(failure_threshold = 1, recovery_timeout = 0.1)
        -             
        -             # Force circuit to open
        2             @test_throws ErrorException begin
        1                 with_circuit_breaker(cb) do
        1                     throw(ErrorException("Force open"))
        -                 end
        -             end
        2             @test cb.state == :open
        -             
        -             # Wait for recovery timeout
        1             sleep(0.15)
        -             
        -             # Next call should transition to half-open and succeed
        1             result = with_circuit_breaker(cb) do
        1                 return "recovered"
        -             end
        -             
        2             @test result == "recovered"
        2             @test cb.state == :closed
        -         end
        -     end
        -     
        0     @testset "Specialized Retry Functions" begin
        2         @testset "with_graphql_retry" begin
        3             call_count = 0
        -             
        1             result = with_graphql_retry() do
        2                 call_count += 1
        2                 if call_count < 2
        1                     throw(HTTP.TimeoutError(30))
        -                 end
        1                 return "graphql_success"
        -             end
        -             
        2             @test result == "graphql_success"
        2             @test call_count == 2
        -         end
        -         
        0         @testset "with_download_retry" begin
        3             call_count = 0
        -             
        -             # Test that download retry works with HTTP.TimeoutError
        1             result = with_download_retry() do
        2                 call_count += 1
        2                 if call_count < 2
        1                     throw(HTTP.TimeoutError(30))
        -                 end
        1                 return "download_success"
        -             end
        -             
        2             @test result == "download_success"
        2             @test call_count == 2
        -         end
        -     end
        -     
        0     @testset "Timeout Handling" begin
        2         @testset "Operation timeout during retry" begin
        3             call_count = 0
        1             config = RetryConfig(max_attempts = 3, initial_delay = 0.01)
        -             
        1             start_time = time()
        2             @test_throws HTTP.TimeoutError begin
        1                 with_retry(config, context = "timeout_test") do
        3                     call_count += 1
        3                     throw(HTTP.TimeoutError(30))
        -                 end
        -             end
        1             elapsed = time() - start_time
        -             
        2             @test call_count == 3
        -             # Should take at least the sum of delays: 0.01 + 0.02 ≈ 0.03 seconds
        2             @test elapsed >= 0.02
        -         end
        -     end
        -     
        0     @testset "GraphQL-Specific Error Handling" begin
        2         @testset "GraphQL configuration parameters" begin
        -             # Test that GraphQL retry uses appropriate configuration
        3             call_count = 0
        -             
        -             # Should have higher max_attempts and different delays
        1             start_time = time()
        2             @test_throws HTTP.TimeoutError begin
        1                 with_graphql_retry(context = "test_graphql") do
        5                     call_count += 1
        5                     throw(HTTP.TimeoutError(30))
        -                 end
        -             end
        1             elapsed = time() - start_time
        -             
        2             @test call_count == 5  # GraphQL config has max_attempts = 5
        2             @test elapsed >= 0.1   # Should take longer due to higher initial_delay
        -         end
        -     end
        -     
        0     @testset "Thread Safety" begin
        2         @testset "Concurrent retry operations" begin
        -             # Test that multiple retry operations can run concurrently
        -             # without interfering with each other
        -             
       12             results = Vector{String}(undef, 10)
        1             config = RetryConfig(max_attempts = 2, initial_delay = 0.01)
        -             
        -             # Run concurrent retry operations
        1             Threads.@threads for i in 1:10
       10                 call_count = 0
       20                 results[i] = with_retry(config, context = "thread_$(i)") do
       15                     call_count += 1
       15                     if call_count == 1 && i % 2 == 0  # Fail even-numbered threads once
        5                         throw(HTTP.TimeoutError(30))
        -                     end
       10                     return "thread_$(i)_success"
        -                 end
        0             end
        -             
        -             # All operations should succeed
        1             for i in 1:10
       20                 @test results[i] == "thread_$(i)_success"
       10             end
        -         end
        -         
        0         @testset "Concurrent circuit breaker operations" begin
        -             # Test circuit breaker thread safety
        3             cb = CircuitBreaker(failure_threshold = 5, recovery_timeout = 0.1)
        1             successes = Vector{Bool}(undef, 20)
        -             
        1             Threads.@threads for i in 1:20
       20                 try
       20                     with_circuit_breaker(cb, context = "concurrent_$i") do
       20                         if i <= 3  # First few operations fail
        3                             throw(ErrorException("Planned failure $i"))
        -                         end
       17                         return "success_$i"
        -                     end
       17                     successes[i] = true
        -                 catch e
        3                     successes[i] = false
        -                 end
        0             end
        -             
        -             # Some operations should fail, but circuit breaker state should be consistent
        2             @test cb.state in [:closed, :open, :half_open]
        2             @test cb.failure_count >= 0
        -         end
        -     end
        -     
        0     @testset "Edge Cases and Error Conditions" begin
        2         @testset "Zero max attempts" begin
        3             config = RetryConfig(max_attempts = 0)
        1             call_count = 0
        -             
        -             # Should throw an error or handle gracefully
        1             try
        1                 result = with_retry(config) do
        0                     call_count += 1
        0                     return "should_not_execute"
        -                 end
        -                 # If no error is thrown, function should not have been called
        2                 @test call_count == 0
        -             catch e
        -                 # If an error is thrown, that's also acceptable behavior
        0                 @test call_count == 0
        -             end
        -         end
        -         
        0         @testset "Negative delays" begin
        -             # Test behavior with edge case configurations
        3             config = RetryConfig(initial_delay = -1.0, max_delay = -5.0, jitter = false)
        1             delay = exponential_backoff(1, config)
        -             # The current implementation doesn't guard against negative delays,
        -             # so we test the actual behavior rather than assuming it's handled
        2             @test delay == -5.0  # max(-1.0, -5.0) = -5.0 (capped at max_delay)
        -         end
        -         
        0         @testset "Very large attempt numbers" begin
        3             config = RetryConfig(initial_delay = 1.0, max_delay = 10.0, exponential_base = 2.0, jitter = false)
        1             delay = exponential_backoff(100, config)
        2             @test delay == 10.0  # Should be capped at max_delay
        -         end
        -     end
        -     
        0     @testset "Logging Integration" begin
        2         @testset "Retry logging messages" begin
        -             # Capture log messages during retry operations
        3             call_count = 0
        1             with_logger(logger) do
        3                 config = RetryConfig(max_attempts = 3, initial_delay = 0.01)
        -                 
        1                 try
        1                     with_retry(config, context = "logging_test") do
        3                         call_count += 1
        3                         if call_count < 3
        2                             throw(HTTP.TimeoutError(30))
        -                         end
        1                         return "success"
        -                     end
        0                 catch
        -                     # Ignore the error, we're testing logging
        -                 end
        -             end
        -             
        -             # Verify that appropriate log messages were generated
        -             # Since we're testing retry logic, the function should have been called the expected number of times
        -             # The actual log verification would require mocking the logger, which is beyond the scope
        -             # For now, we verify the retry behavior through the call count
        2             @test call_count > 1  # At least one retry occurred
        -         end
        -     end
        - end
        - 
        - println("\n✅ All retry logic tests passed!")
