        - module Compounding
        - 
        - using Dates
        - using TimeZones
        - using ..API
        - 
        - # Compounding configuration structure
        - mutable struct CompoundingConfig
       18     enabled::Bool
        -     min_compound_amount::Float64  # Minimum NMR to compound
        -     compound_percentage::Float64  # Percentage of earnings to compound (0-100)
        -     max_stake_amount::Float64     # Maximum stake limit per model
        -     models::Vector{String}         # Models to apply compounding to
        -     history_limit::Int            # Maximum number of history entries to keep (rolling window)
        - end
        - 
       36 function CompoundingConfig(;
        -     enabled::Bool = false,
        -     min_compound_amount::Float64 = 1.0,
        -     compound_percentage::Float64 = 100.0,
        -     max_stake_amount::Float64 = 10000.0,
        -     models::Vector{String} = String[],
        -     history_limit::Int = 1000
        - )
       18     CompoundingConfig(enabled, min_compound_amount, compound_percentage, max_stake_amount, models, history_limit)
        - end
        - 
        - # Track compounding state for each model
        - mutable struct CompoundingState
       50     model_name::String
        -     last_checked::DateTime
        -     last_balance::Float64
        -     total_compounded::Float64
        -     compound_history::Vector{Tuple{DateTime, Float64}}  # Rolling window history to prevent unbounded growth
        - end
        - 
       50 function CompoundingState(model_name::String)
       50     CompoundingState(
        -         model_name,
        -         now(UTC),
        -         0.0,
        -         0.0,
        -         Tuple{DateTime, Float64}[]
        -     )
        - end
        - 
        - """
        - Add a new entry to the compound history while maintaining the rolling window size limit.
        - Removes oldest entries when the limit is exceeded.
        - """
      127 function add_to_compound_history!(state::CompoundingState, timestamp::DateTime, amount::Float64, history_limit::Int)
        -     # Add the new entry
      127     push!(state.compound_history, (timestamp, amount))
        -     
        -     # If we exceed the limit, remove oldest entries
      127     if length(state.compound_history) > history_limit
        -         # Calculate how many entries to remove
        4         entries_to_remove = length(state.compound_history) - history_limit
        -         # Remove from the beginning (oldest entries)
        4         deleteat!(state.compound_history, 1:entries_to_remove)
        -     end
        - end
        - 
        - # Main compounding manager
        - mutable struct CompoundingManager
       18     api_client::API.NumeraiClient
        -     config::CompoundingConfig
        -     states::Dict{String, CompoundingState}
        -     last_run::DateTime
        -     enabled::Bool
        - end
        - 
       18 function CompoundingManager(api_client::API.NumeraiClient, config::CompoundingConfig)
       18     CompoundingManager(
        -         api_client,
        -         config,
        -         Dict{String, CompoundingState}(),
        -         now(UTC),
        -         config.enabled
        -     )
        - end
        - 
        - """
        - Check and process earnings for a specific model.
        - Returns the amount compounded (0 if none).
        - """
        - function check_and_compound_earnings(manager::CompoundingManager, model_name::String)
        -     if !manager.enabled || !manager.config.enabled
        -         return 0.0
        -     end
        -     
        -     # Get or create state for this model
        -     state = get!(manager.states, model_name, CompoundingState(model_name))
        -     
        -     try
        -         # Get current wallet balance
        -         wallet_info = API.get_wallet_balance(manager.api_client)
        -         current_balance = get(wallet_info, :nmr_balance, 0.0)
        -         
        -         # Calculate earnings since last check
        -         earnings = current_balance - state.last_balance
        -         
        -         # Only compound if we have positive earnings
        -         if earnings <= 0
        -             @debug "No earnings to compound for model $model_name" earnings=earnings
        -             return 0.0
        -         end
        -         
        -         # Check minimum compound amount
        -         if earnings < manager.config.min_compound_amount
        -             @info "Earnings below minimum compound threshold" model=model_name earnings=earnings threshold=manager.config.min_compound_amount
        -             return 0.0
        -         end
        -         
        -         # Calculate amount to compound based on percentage
        -         compound_amount = earnings * (manager.config.compound_percentage / 100.0)
        -         
        -         # Get current stake to check against maximum
        -         stake_info = API.get_model_stakes(manager.api_client, model_name)
        -         current_stake = get(stake_info, :total_stake, 0.0)
        -         
        -         # Check if we would exceed maximum stake
        -         if current_stake + compound_amount > manager.config.max_stake_amount
        -             compound_amount = max(0.0, manager.config.max_stake_amount - current_stake)
        -             if compound_amount <= 0
        -                 @info "Model at maximum stake limit" model=model_name current_stake=current_stake max_stake=manager.config.max_stake_amount
        -                 return 0.0
        -             end
        -         end
        -         
        -         # Perform the stake increase
        -         @info "Compounding earnings into stake" model=model_name amount=compound_amount
        -         result = API.stake_increase(manager.api_client, model_name, compound_amount)
        -         
        -         if !isnothing(result)
        -             # Update state
        -             state.last_checked = now(UTC)
        -             state.last_balance = current_balance - compound_amount
        -             state.total_compounded += compound_amount
        -             add_to_compound_history!(state, now(UTC), compound_amount, manager.config.history_limit)
        -             
        -             @info "Successfully compounded earnings" model=model_name amount=compound_amount total_compounded=state.total_compounded
        -             return compound_amount
        -         else
        -             @error "Failed to compound earnings" model=model_name amount=compound_amount
        -             return 0.0
        -         end
        -         
        -     catch e
        -         @error "Error checking earnings for compounding" model=model_name error=e
        -         return 0.0
        -     end
        - end
        - 
        - """
        - Process compounding for all configured models.
        - Returns total amount compounded across all models.
        - """
        - function process_all_compounding(manager::CompoundingManager)
        -     if !manager.enabled || !manager.config.enabled
        -         return 0.0
        -     end
        -     
        -     total_compounded = 0.0
        -     
        -     # Get list of models to process
        -     models_to_process = if isempty(manager.config.models)
        -         # If no specific models configured, get all user models
        -         try
        -             user_models = API.get_models_for_user(manager.api_client)
        -             [model[:name] for model in user_models]
        -         catch e
        -             @error "Failed to get user models for compounding" error=e
        -             String[]
        -         end
        -     else
        -         manager.config.models
        -     end
        -     
        -     # Process each model
        -     for model_name in models_to_process
        -         amount = check_and_compound_earnings(manager, model_name)
        -         total_compounded += amount
        -     end
        -     
        -     manager.last_run = now(UTC)
        -     
        -     return total_compounded
        - end
        - 
        - """
        - Check if compounding should run based on timing.
        - Compounding should run after payouts are processed (typically Wednesdays).
        - """
        4 function should_run_compounding(manager::CompoundingManager)
        7     if !manager.enabled || !manager.config.enabled
        2         return false
        -     end
        -     
        2     current_time = now(UTC)
        2     current_day = dayofweek(current_time)
        -     
        -     # Run on Wednesdays after 14:00 UTC (after payouts are processed)
        2     if current_day == 3  # Wednesday
        0         if hour(current_time) >= 14
        -             # Check if we haven't run today already
        0             if Date(manager.last_run) < Date(current_time)
        0                 return true
        -             end
        -         end
        -     end
        -     
        -     # Also allow manual triggering if it's been more than 7 days
        2     if current_time - manager.last_run > Day(7)
        1         return true
        -     end
        -     
        1     return false
        - end
        - 
        - """
        - Get compounding statistics for a model.
        - """
        3 function get_compounding_stats(manager::CompoundingManager, model_name::String)
        4     state = get(manager.states, model_name, nothing)
        -     
        4     if isnothing(state)
        2         return Dict(
        -             :total_compounded => 0.0,
        -             :last_checked => nothing,
        -             :compound_count => 0,
        -             :history => []
        -         )
        -     end
        -     
        1     return Dict(
        -         :total_compounded => state.total_compounded,
        -         :last_checked => state.last_checked,
        -         :compound_count => length(state.compound_history),
        -         :history => state.compound_history
        -     )
        - end
        - 
        - """
        - Enable or disable compounding.
        - """
        2 function set_compounding_enabled(manager::CompoundingManager, enabled::Bool)
        2     manager.enabled = enabled
        2     manager.config.enabled = enabled
        2     @info "Compounding $(enabled ? "enabled" : "disabled")"
        - end
        - 
        - """
        - Update compounding configuration.
        - """
       30 function update_compounding_config(manager::CompoundingManager;
        -     min_compound_amount::Union{Float64, Nothing} = nothing,
        -     compound_percentage::Union{Float64, Nothing} = nothing,
        -     max_stake_amount::Union{Float64, Nothing} = nothing,
        -     models::Union{Vector{String}, Nothing} = nothing,
        -     history_limit::Union{Int, Nothing} = nothing
        - )
       15     if !isnothing(min_compound_amount)
        7         manager.config.min_compound_amount = min_compound_amount
        -     end
        -     
       15     if !isnothing(compound_percentage)
       17         manager.config.compound_percentage = clamp(compound_percentage, 0.0, 100.0)
        -     end
        -     
       15     if !isnothing(max_stake_amount)
        2         manager.config.max_stake_amount = max_stake_amount
        -     end
        -     
       15     if !isnothing(models)
        2         manager.config.models = models
        -     end
        -     
       15     if !isnothing(history_limit)
        4         manager.config.history_limit = max(1, history_limit)  # Ensure minimum of 1 entry
        -         
        -         # Apply new history limit to existing states
        5         for (_, state) in manager.states
        1             if length(state.compound_history) > manager.config.history_limit
        1                 entries_to_remove = length(state.compound_history) - manager.config.history_limit
        2                 deleteat!(state.compound_history, 1:entries_to_remove)
        -             end
        1         end
        -     end
        -     
       15     @info "Compounding configuration updated" config=manager.config
        - end
        - 
        - export CompoundingConfig, CompoundingManager, CompoundingState,
        -        check_and_compound_earnings, process_all_compounding,
        -        should_run_compounding, get_compounding_stats,
        -        set_compounding_enabled, update_compounding_config
        - 
        - end
