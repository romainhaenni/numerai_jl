        - module Preprocessor
        - 
        - using DataFrames
        - using Statistics
        - using StatsBase
        - using LinearAlgebra
        - using Distributions
        - 
        6 function fillna(df::DataFrame, value::Float64=0.0)::DataFrame
        6     df_copy = copy(df)
        5     for col in names(df_copy)
      164         df_copy[!, col] = coalesce.(df_copy[!, col], value)
      164     end
        5     return df_copy
        - end
        - 
        2 function rank_normalize(values::Vector{Float64})::Vector{Float64}
        2     n = length(values)
        2     ranks = ordinalrank(values)
        2     return (ranks .- 0.5) ./ n
        - end
        - 
        1 function rank_predictions(predictions::Vector{Float64})::Vector{Float64}
        1     return rank_normalize(predictions)
        - end
        - 
        1 function gaussianize(values::Vector{Float64})::Vector{Float64}
        1     ranks = rank_normalize(values)
        -     
        1     lower_bound = 1.0 / (2 * length(values))
        1     upper_bound = 1.0 - lower_bound
        2     ranks = clamp.(ranks, lower_bound, upper_bound)
        -     
        1     return quantile.(Normal(), ranks)
        - end
        - 
        - function neutralize_series(series::Vector{Float64}, by::Matrix{Float64})::Vector{Float64}
        -     if size(by, 1) != length(series)
        -         error("Series length must match neutralization matrix rows")
        -     end
        -     
        -     exposures = by \ series
        -     
        -     neutralized = series - by * exposures
        -     
        -     return neutralized
        - end
        - 
        3 function normalize_predictions(predictions::Vector{Float64})::Vector{Float64}
        3     min_val, max_val = extrema(predictions)
        -     
        3     if min_val == max_val
        0         return fill(0.5, length(predictions))
        -     end
        -     
        6     normalized = (predictions .- min_val) ./ (max_val - min_val)
        -     
        6     normalized = clamp.(normalized, 0.001, 0.999)
        -     
        3     return normalized
        - end
        - 
        - function feature_importance_filter(X::DataFrame, y::Vector{Float64}; 
        -                                   threshold::Float64=0.0)::Vector{String}
        -     important_features = String[]
        -     
        -     for col in names(X)
        -         correlation = cor(X[!, col], y)
        -         if abs(correlation) > threshold
        -             push!(important_features, col)
        -         end
        -     end
        -     
        -     return important_features
        - end
        - 
        - function create_era_weighted_features(df::DataFrame, era_col::Symbol)::DataFrame
        -     result = copy(df)
        -     eras = df[!, era_col]
        -     unique_eras = unique(eras)
        -     
        -     for era in unique_eras
        -         era_mask = eras .== era
        -         era_weight = 1.0 / sum(era_mask)
        -         
        -         for col in names(df)
        -             if col != era_col
        -                 result[era_mask, col] = df[era_mask, col] .* sqrt(era_weight)
        -             end
        -         end
        -     end
        -     
        -     return result
        - end
        - 
        4 function clip_predictions(predictions::Vector{Float64}; lower::Float64=0.0003, upper::Float64=0.9997)::Vector{Float64}
        2     return clamp.(predictions, lower, upper)
        - end
        - 
        - function ensemble_predictions(predictions_list::Vector{Vector{Float64}}; 
        -                             weights::Union{Nothing,Vector{Float64}}=nothing)::Vector{Float64}
        -     if isempty(predictions_list)
        -         error("No predictions to ensemble")
        -     end
        -     
        -     n_models = length(predictions_list)
        -     n_samples = length(predictions_list[1])
        -     
        -     if weights === nothing
        -         weights = fill(1.0 / n_models, n_models)
        -     end
        -     
        -     if length(weights) != n_models
        -         error("Number of weights must match number of models")
        -     end
        -     
        -     weights = weights ./ sum(weights)
        -     
        -     ensemble = zeros(n_samples)
        -     for (i, preds) in enumerate(predictions_list)
        -         ensemble .+= preds .* weights[i]
        -     end
        -     
        -     return ensemble
        - end
        - 
        - function reduce_memory_usage(df::DataFrame)::DataFrame
        -     result = DataFrame()
        -     
        -     for col in names(df)
        -         col_data = df[!, col]
        -         
        -         if eltype(col_data) <: Real
        -             min_val, max_val = extrema(skipmissing(col_data))
        -             
        -             if all(x -> isinteger(x) || ismissing(x), col_data)
        -                 if min_val >= typemin(Int8) && max_val <= typemax(Int8)
        -                     result[!, col] = Int8.(coalesce.(col_data, 0))
        -                 elseif min_val >= typemin(Int16) && max_val <= typemax(Int16)
        -                     result[!, col] = Int16.(coalesce.(col_data, 0))
        -                 elseif min_val >= typemin(Int32) && max_val <= typemax(Int32)
        -                     result[!, col] = Int32.(coalesce.(col_data, 0))
        -                 else
        -                     result[!, col] = col_data
        -                 end
        -             else
        -                 if abs(max_val - min_val) < 1000 && abs(max_val) < 1e6
        -                     result[!, col] = Float32.(col_data)
        -                 else
        -                     result[!, col] = col_data
        -                 end
        -             end
        -         else
        -             result[!, col] = col_data
        -         end
        -     end
        -     
        -     return result
        - end
        - 
        - export fillna, rank_normalize, rank_predictions, gaussianize, neutralize_series, normalize_predictions,
        -        feature_importance_filter, create_era_weighted_features, clip_predictions,
        -        ensemble_predictions, reduce_memory_usage
        - 
        - end
